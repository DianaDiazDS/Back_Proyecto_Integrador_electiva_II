# -*- coding: utf-8 -*-
"""Copia del proyecto

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KGri5u9nSW8QvGA0yvQGr24oEgA1LD4l
"""

import tensorflow as tf

import os
from google.cloud import dialogflow_v2 as dialogflow
import json

import pandas as pd
import numpy as np
import threading

import nest_asyncio

from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import JSONResponse
from typing import Optional
import shutil
import uuid

# Configuraciones generales
import warnings
warnings.filterwarnings('ignore')

from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.efficientnet import preprocess_input

from huggingface_hub import hf_hub_download
from tensorflow.keras.layers import Layer
import tensorflow.keras.backend as K
from dotenv import load_dotenv


from google.oauth2 import service_account

load_dotenv()

# Leer variables del entorno
credentials_info = {
    "type": os.getenv("TYPE"),
    "project_id": os.getenv("PROJECT_ID"),
    "private_key_id": os.getenv("PRIVATE_KEY_ID"),
    "private_key": os.getenv("PRIVATE_KEY").replace("\\n", "\n"),  # Cuidado con el salto de línea
    "client_email": os.getenv("CLIENT_EMAIL"),
    "client_id": os.getenv("CLIENT_ID"),
    "auth_uri": os.getenv("AUTH_URI"),
    "token_uri": os.getenv("TOKEN_URI"),
    "auth_provider_x509_cert_url": os.getenv("AUTH_PROVIDER_X509_CERT_URL"),
    "client_x509_cert_url": os.getenv("CLIENT_X509_CERT_URL"),
    "universe_domain": os.getenv("UNIVERSE_DOMAIN")
}

# Crear credenciales desde el diccionario
credentials = service_account.Credentials.from_service_account_info(credentials_info)

# Crear cliente Dialogflow con las credenciales
session_client = dialogflow.SessionsClient(credentials=credentials)

# Parámetros de sesión
project_id = credentials_info["project_id"]
session_id = "session1"
language_code = "es"

# Probar la conexión
try:
    credentials = service_account.Credentials.from_service_account_info(credentials_info)
    session_client = dialogflow.SessionsClient(credentials=credentials)
    print("Conexión exitosa a Dialogflow")
except Exception as e:
    print(f" Error de conexión: {e}")

# Descargar el modelo
model_path = hf_hub_download(repo_id="liriope/PlantDiseaseDetection", filename="plant_disease_efficientnetb4.h5")

# Cargar el modelo completo incluyendo la capa personalizada
modelo_cnn = tf.keras.models.load_model(model_path)

# Acceso a drive
# drive.mount('/content/drive')

# path_imagenes = "/content/drive/MyDrive/Colab Notebooks/MODULO7/proyecto/Proyecto Integrador/Imagenes prueba/"
# path_modelos = "/content/drive/MyDrive/Colab Notebooks/MODULO7/proyecto/Proyecto Integrador/Modelos/"
# path_credenciales =  "/content/drive/MyDrive/Colab Notebooks/MODULO7/proyecto/Proyecto Integrador/Credenciales/"

"""Urilizar modelo desde Huggong Face

https://huggingface.co/liriope/PlantDiseaseDetection
"""

diccionario_es = {
    0: 'Manzana Sarna del manzano',
    1: 'Manzana Podredumbre negra',
    2: 'Manzana Oxido del cedro y manzano',
    3: 'Manzana sana',
    4: 'Arándano sano',
    5: 'Cereza (incluyendo agria) mildiú polvoroso',
   6: 'Cereza (incluyendo agria) sana',
   7: 'Maíz Mancha foliar de Cercospora Mancha gris de la hoja',
   8: 'Maíz Roya común',
   9: 'Maíz Tizón foliar del norte',
   10: 'Maíz sano',
   11: 'Uva Podredumbre negra',
   12: 'Uva Esca (Yesca)',
   13: 'Uva Tizón de la hoja (Mancha foliar de Isariopsis)',
   14: 'Uva sana',
   15: 'Naranja Huanglongbing (Greening de los cítricos)',
   16: 'Melocotón Mancha bacteriana',
   17: 'Melocotón sano',
   18: 'Pimiento Mancha bacteriana',
   19: 'Pimiento sano',
   20: 'Papa Tizón temprano',
   21: 'Papa Tizón tardío',
   22: 'Papa sana',
   23: 'Frambuesa sana',
   24: 'Soja sana',
   25: 'Calabaza Oídio',
   26: 'Fresa Quemadura de la hoja',
   27: 'Fresa sana',
   28: 'Tomate Mancha bacteriana',
   29: 'Tomate Tizón temprano',
   30: 'Tomate Tizón tardío',
   31: 'Tomate Moho de la hoja',
   32: 'Tomate Mancha foliar de Septoria',
   33: 'Tomate Araña roja Ácaro de dos puntos',
   34: 'Tomate Mancha objetivo',
   35: 'Tomate Virus del enrollamiento de la hoja amarilla del tomate',
   36: 'Tomate Virus del mosaico del tomate',
   37: 'Tomate sano'
}

"""## Dialog Flow"""

import numpy as np
import requests
from io import BytesIO
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.efficientnet import preprocess_input

def AnalizarEnfermedadHoja(path_imagen):
    try:
        # Detectar si es una URL o una ruta local
        if path_imagen.startswith("http://") or path_imagen.startswith("https://"):
            response = requests.get(path_imagen)
            if response.status_code != 200:
                return "No se pudo acceder a la imagen desde la URL"
            img = image.load_img(BytesIO(response.content), target_size=(380, 380))
        else:
            img = image.load_img(path_imagen, target_size=(380, 380))

        img_array = image.img_to_array(img)
        img_array = np.expand_dims(img_array, axis=0)
        img_array = preprocess_input(img_array)

        predictions = modelo_cnn.predict(img_array)
        predicted_index = np.argmax(predictions)
        return diccionario_es.get(predicted_index, "Desconocido")

    except Exception as e:
        return f"Error al procesar la imagen: {str(e)}"

"""### credenciales"""

# Función conversacional completa
def detec_intent_texts_full(project_id, session_id, text, language_code):
  session_client = dialogflow.SessionsClient()
  session = session_client.session_path(project_id, session_id)

  text_input = dialogflow.TextInput(text=text, language_code=language_code)
  query_input = dialogflow.QueryInput(text=text_input)

  response = session_client.detect_intent(
      request={"session" : session, "query_input": query_input}
  )

  # Extraer información importante:
  fulfillment_text = response.query_result.fulfillment_text # texto que retorna el agente
  intent = response.query_result.intent.display_name # intención que retorna el agente
  confianza = response.query_result.intent_detection_confidence # confianza del agente al clasificar esa intención 0 - 1
  parametros = dict(response.query_result.parameters) # ... parámetros de la intención

  # Crear un diccionario con la información
  return {
      "respuesta": fulfillment_text,
      "intencion": intent,
      "confianza": confianza,
      "parametros": dict(parametros)
  }

"""# **Uso dialogflow**

# **FastAPI**
"""

# !ngrok config add-authtoken 2ueWlmy8gMJ6AOv9EVOV75b556b_3PwVsjgVrVPmuNKD13prY

from fastapi import FastAPI, File, Form, UploadFile
from fastapi.responses import JSONResponse
from typing import Optional
import uuid
import shutil
import uvicorn
import nest_asyncio

# Requerido si estás en Colab o Jupyter
import re
nest_asyncio.apply()

def extraer_url(texto):
    urls = re.findall(r'(https?://\S+)', texto)
    return urls[0] if urls else None
from fastapi.middleware.cors import CORSMiddleware
app = FastAPI(title="backend-api")
app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],  # Puedes especificar tu URL de frontend en lugar de "*"
    allow_credentials=True,
    allow_methods=["*"],
    allow_headers=["*"],
)

@app.get("/")
async def home():
    return JSONResponse(content="API del backend del proyecto integrador")


@app.post("/conversar")
async def conversar(
    mensaje: str = Form(...),
    imagen: Optional[UploadFile] = File(None)):

    resultado = detec_intent_texts_full(project_id, session_id, mensaje, language_code)

    imagen_path = None

    # Caso 1: imagen cargada directamente
    if imagen:
        extension = imagen.filename.split('.')[-1]
        filename = f"{uuid.uuid4()}.{extension}"
        imagen_path = os.path.join("uploads", filename)
        os.makedirs("uploads", exist_ok=True)

        with open(imagen_path, "wb") as buffer:
            shutil.copyfileobj(imagen.file, buffer)

        resultado["imagen_guardada"] = imagen_path
        resultado["prediccion"] = AnalizarEnfermedadHoja(imagen_path)

    # Caso 2: se envió una URL en el mensaje
    else:
        url_detectada = extraer_url(mensaje)
        if url_detectada:
            resultado["url_detectada"] = url_detectada
            resultado["prediccion"] = AnalizarEnfermedadHoja(url_detectada)

    return JSONResponse(content=resultado)

# # Conexión con ngrok
# public_url = ngrok.connect(8000)
# print(f"API disponible en: {public_url}")

# Ejecutar servidor
# uvicorn.run(app, host="0.0.0.0", port=8000)
if __name__ == "__main__":
    
    uvicorn.run(app, host="0.0.0.0", port=8000)