# -*- coding: utf-8 -*-
"""Copia del proyecto

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1KGri5u9nSW8QvGA0yvQGr24oEgA1LD4l
"""
import os
os.environ['TF_CPP_MIN_LOG_LEVEL'] = '2'

import tensorflow as tf

import os
from google.cloud import dialogflow_v2 as dialogflow
import json

import pandas as pd
import numpy as np
import threading

import nest_asyncio

from fastapi import FastAPI, File, UploadFile, Form
from fastapi.responses import JSONResponse
from typing import Optional
import shutil
import uuid

# Configuraciones generales
import warnings
warnings.filterwarnings('ignore')

from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.efficientnet import preprocess_input

from huggingface_hub import hf_hub_download
from tensorflow.keras.layers import Layer
import tensorflow.keras.backend as K
from dotenv import load_dotenv


from google.oauth2 import service_account

load_dotenv()

# Leer variables del entorno
credentials_info = {
    "type": os.getenv("TYPE"),
    "project_id": os.getenv("PROJECT_ID"),
    "private_key_id": os.getenv("PRIVATE_KEY_ID"),
    "private_key": os.getenv("PRIVATE_KEY").replace("\\n", "\n"),  # Cuidado con el salto de línea
    "client_email": os.getenv("CLIENT_EMAIL"),
    "client_id": os.getenv("CLIENT_ID"),
    "auth_uri": os.getenv("AUTH_URI"),
    "token_uri": os.getenv("TOKEN_URI"),
    "auth_provider_x509_cert_url": os.getenv("AUTH_PROVIDER_X509_CERT_URL"),
    "client_x509_cert_url": os.getenv("CLIENT_X509_CERT_URL"),
    "universe_domain": os.getenv("UNIVERSE_DOMAIN")
}

# Crear credenciales desde el diccionario
credentials = service_account.Credentials.from_service_account_info(credentials_info)

# Crear cliente Dialogflow con las credenciales
session_client = dialogflow.SessionsClient(credentials=credentials)

# Parámetros de sesión
project_id = credentials_info["project_id"]
session_id = "session1"
language_code = "es"

# Probar la conexión
try:
    credentials = service_account.Credentials.from_service_account_info(credentials_info)
    session_client = dialogflow.SessionsClient(credentials=credentials)
    print("Conexión exitosa a Dialogflow")
except Exception as e:
    print(f" Error de conexión: {e}")

# Descargar el modelo
#model_path = hf_hub_download(repo_id="liriope/PlantDiseaseDetection", filename="plant_disease_efficientnetb4.h5")

# Cargar el modelo completo incluyendo la capa personalizada
#modelo_cnn = tf.keras.models.load_model(model_path)
modelo_cnn = tf.keras.models.load_model("plant_disease_efficientnetb4.h5")
# Acceso a drive
# drive.mount('/content/drive')

# path_imagenes = "/content/drive/MyDrive/Colab Notebooks/MODULO7/proyecto/Proyecto Integrador/Imagenes prueba/"
# path_modelos = "/content/drive/MyDrive/Colab Notebooks/MODULO7/proyecto/Proyecto Integrador/Modelos/"
# path_credenciales =  "/content/drive/MyDrive/Colab Notebooks/MODULO7/proyecto/Proyecto Integrador/Credenciales/"

"""Urilizar modelo desde Huggong Face

https://huggingface.co/liriope/PlantDiseaseDetection
"""

diccionario_es = {
    0: 'Manzana Sarna del manzano',
    1: 'Manzana Podredumbre negra',
    2: 'Manzana Oxido del cedro y manzano',
    3: 'Manzana sana',
    4: 'Arándano sano',
    5: 'Cereza (incluyendo agria) mildiú polvoroso',
   6: 'Cereza (incluyendo agria) sana',
   7: 'Maíz Mancha foliar de Cercospora Mancha gris de la hoja',
   8: 'Maíz Roya común',
   9: 'Maíz Tizón foliar del norte',
   10: 'Maíz sano',
   11: 'Uva Podredumbre negra',
   12: 'Uva Esca (Yesca)',
   13: 'Uva Tizón de la hoja (Mancha foliar de Isariopsis)',
   14: 'Uva sana',
   15: 'Naranja Huanglongbing (Greening de los cítricos)',
   16: 'Melocotón Mancha bacteriana',
   17: 'Melocotón sano',
   18: 'Pimiento Mancha bacteriana',
   19: 'Pimiento sano',
   20: 'Papa Tizón temprano',
   21: 'Papa Tizón tardío',
   22: 'Papa sana',
   23: 'Frambuesa sana',
   24: 'Soja sana',
   25: 'Calabaza Oídio',
   26: 'Fresa Quemadura de la hoja',
   27: 'Fresa sana',
   28: 'Tomate Mancha bacteriana',
   29: 'Tomate Tizón temprano',
   30: 'Tomate Tizón tardío',
   31: 'Tomate Moho de la hoja',
   32: 'Tomate Mancha foliar de Septoria',
   33: 'Tomate Araña roja Ácaro de dos puntos',
   34: 'Tomate Mancha objetivo',
   35: 'Tomate Virus del enrollamiento de la hoja amarilla del tomate',
   36: 'Tomate Virus del mosaico del tomate',
   37: 'Tomate sano'
}

"""## Dialog Flow"""

import numpy as np
import requests
from io import BytesIO
from tensorflow.keras.preprocessing import image
from tensorflow.keras.applications.efficientnet import preprocess_input

def AnalizarEnfermedadHoja(path_imagen):
    try:
        # Detectar si es una URL o una ruta local
        if path_imagen.startswith("http://") or path_imagen.startswith("https://"):
            response = requests.get(path_imagen)
            if response.status_code != 200:
                return "No se pudo acceder a la imagen desde la URL"
            img = image.load_img(BytesIO(response.content), target_size=(380, 380))
        else:
            img = image.load_img(path_imagen, target_size=(380, 380))

        img_array = image.img_to_array(img)
        img_array = np.expand_dims(img_array, axis=0)
        img_array = preprocess_input(img_array)

        predictions = modelo_cnn.predict(img_array)
        predicted_index = np.argmax(predictions)
        return diccionario_es.get(predicted_index, "Desconocido")

    except Exception as e:
        return f"Error al procesar la imagen: {str(e)}"

"""### credenciales"""

# Función conversacional completa
def detec_intent_texts_full(project_id, session_id, text, language_code):
  session_client = dialogflow.SessionsClient()
  session = session_client.session_path(project_id, session_id)

  text_input = dialogflow.TextInput(text=text, language_code=language_code)
  query_input = dialogflow.QueryInput(text=text_input)

  response = session_client.detect_intent(
      request={"session" : session, "query_input": query_input}
  )

  # Extraer información importante:
  fulfillment_text = response.query_result.fulfillment_text # texto que retorna el agente
  intent = response.query_result.intent.display_name # intención que retorna el agente
  confianza = response.query_result.intent_detection_confidence # confianza del agente al clasificar esa intención 0 - 1
  parametros = dict(response.query_result.parameters) # ... parámetros de la intención

  # Crear un diccionario con la información
  return {
      "respuesta": fulfillment_text,
      "intencion": intent,
      "confianza": confianza,
      "parametros": dict(parametros)
  }

"""# **Uso dialogflow**

# **FastAPI**
"""

# !ngrok config add-authtoken 2ueWlmy8gMJ6AOv9EVOV75b556b_3PwVsjgVrVPmuNKD13prY

from flask import Flask, request, jsonify
from flask_cors import CORS
from werkzeug.utils import secure_filename
import os, uuid, re

app = Flask(__name__)
app.config['UPLOAD_FOLDER'] = 'uploads'
os.makedirs(app.config['UPLOAD_FOLDER'], exist_ok=True)
CORS(app, origins="*")  # No pongas supports_credentials=True

@app.route('/')
def home():
    return jsonify("API del backend del proyecto integrador")

@app.route('/conversar', methods=['POST'])
def conversar():
    mensaje = request.form.get('mensaje', '')
    imagen = request.files.get('imagen')

    resultado = detec_intent_texts_full(project_id, session_id, mensaje, language_code)

    if imagen:
        filename = secure_filename(imagen.filename)
        path = os.path.join(app.config['UPLOAD_FOLDER'], f"{uuid.uuid4()}.{filename.rsplit('.', 1)[-1]}")
        imagen.save(path)
        resultado["imagen_guardada"] = path
        resultado["prediccion"] = AnalizarEnfermedadHoja(path)
    else:
        url = re.search(r'(https?://\S+)', mensaje)
        if url:
            url = url.group(0)
            resultado["url_detectada"] = url
            resultado["prediccion"] = AnalizarEnfermedadHoja(url)

    return jsonify(resultado)
